{"version":3,"names":[],"mappings":"","sources":["himalaya.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.himalaya = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayIncludes = arrayIncludes;\nexports.endsWith = endsWith;\nexports.isRealNaN = isRealNaN;\nexports.startsWith = startsWith;\nexports.stringIncludes = stringIncludes;\n\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.format = format;\nexports.formatAttributes = formatAttributes;\nexports.splitHead = splitHead;\nexports.unquote = unquote;\n\nfunction splitHead(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n}\n\nfunction unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n\n  return str;\n}\n\nfunction format(nodes, options) {\n  return nodes.map(function (node) {\n    var type = node.type;\n    var outputNode = type === 'element' ? {\n      type: type,\n      tagName: node.tagName.toLowerCase(),\n      attributes: formatAttributes(node.attributes),\n      children: format(node.children, options)\n    } : {\n      type: type,\n      content: node.content\n    };\n\n    if (options.includePositions) {\n      outputNode.position = node.position;\n    }\n\n    return outputNode;\n  });\n}\n\nfunction formatAttributes(attributes) {\n  return attributes.map(function (attribute) {\n    var parts = splitHead(attribute.trim(), '=');\n    var key = parts[0];\n    var value = typeof parts[1] === 'string' ? unquote(parts[1]) : null;\n    return {\n      key: key,\n      value: value\n    };\n  });\n}\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseDefaults = void 0;\nexports.stringify = stringify;\n\nvar _lexer = _interopRequireDefault(require(\"./lexer\"));\n\nvar _parser = _interopRequireDefault(require(\"./parser\"));\n\nvar _format = require(\"./format\");\n\nvar _stringify = require(\"./stringify\");\n\nvar _tags = require(\"./tags\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers,\n  includePositions: false\n};\nexports.parseDefaults = parseDefaults;\n\nfunction parse(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n  var tokens = (0, _lexer[\"default\"])(str, options);\n  var nodes = (0, _parser[\"default\"])(tokens, options);\n  return (0, _format.format)(nodes, options);\n}\n\nfunction stringify(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n  return (0, _stringify.toHTML)(ast, options);\n}\n\n},{\"./format\":2,\"./lexer\":4,\"./parser\":5,\"./stringify\":6,\"./tags\":7}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copyPosition = copyPosition;\nexports[\"default\"] = lexer;\nexports.feedPosition = feedPosition;\nexports.findTextEnd = findTextEnd;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.jumpPosition = jumpPosition;\nexports.lex = lex;\nexports.lexComment = lexComment;\nexports.lexSkipTag = lexSkipTag;\nexports.lexTag = lexTag;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexTagName = lexTagName;\nexports.lexText = lexText;\nexports.makeInitialPosition = makeInitialPosition;\n\nvar _compat = require(\"./compat\");\n\nfunction feedPosition(position, str, len) {\n  var start = position.index;\n  var end = position.index = start + len;\n\n  for (var i = start; i < end; i++) {\n    var _char = str.charAt(i);\n\n    if (_char === '\\n') {\n      position.line++;\n      position.column = 0;\n    } else {\n      position.column++;\n    }\n  }\n}\n\nfunction jumpPosition(position, str, end) {\n  var len = end - position.index;\n  return feedPosition(position, str, len);\n}\n\nfunction makeInitialPosition() {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  };\n}\n\nfunction copyPosition(position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  };\n}\n\nfunction lexer(str, options) {\n  var state = {\n    str: str,\n    options: options,\n    position: makeInitialPosition(),\n    tokens: []\n  };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str,\n      childlessTags = state.options.childlessTags;\n  var len = str.length;\n\n  while (state.position.index < len) {\n    var start = state.position.index;\n    lexText(state);\n\n    if (state.position.index === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', start + 1);\n\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\n\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n\n    if (textEnd === -1) {\n      return textEnd;\n    }\n\n    var _char2 = str.charAt(textEnd + 1);\n\n    if (_char2 === '/' || _char2 === '!' || alphanumeric.test(_char2)) {\n      return textEnd;\n    }\n\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      position = state.position;\n  var textEnd = findTextEnd(str, position.index);\n  if (textEnd === position.index) return;\n\n  if (textEnd === -1) {\n    textEnd = str.length;\n  }\n\n  var start = copyPosition(position);\n  var content = str.slice(position.index, textEnd);\n  jumpPosition(position, str, textEnd);\n  var end = copyPosition(position);\n  state.tokens.push({\n    type: type,\n    content: content,\n    position: {\n      start: start,\n      end: end\n    }\n  });\n}\n\nfunction lexComment(state) {\n  var str = state.str,\n      position = state.position;\n  var start = copyPosition(position);\n  feedPosition(position, str, 4); // \"<!--\".length\n\n  var contentEnd = str.indexOf('-->', position.index);\n  var commentEnd = contentEnd + 3; // \"-->\".length\n\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length;\n  }\n\n  var content = str.slice(position.index, contentEnd);\n  jumpPosition(position, str, commentEnd);\n  state.tokens.push({\n    type: 'comment',\n    content: content,\n    position: {\n      start: start,\n      end: copyPosition(position)\n    }\n  });\n}\n\nfunction lexTag(state) {\n  var str = state.str,\n      position = state.position;\n  {\n    var secondChar = str.charAt(position.index + 1);\n    var close = secondChar === '/';\n    var start = copyPosition(position);\n    feedPosition(position, str, close ? 2 : 1);\n    state.tokens.push({\n      type: 'tag-start',\n      close: close,\n      position: {\n        start: start\n      }\n    });\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(position.index);\n\n    var _close = firstChar === '/';\n\n    feedPosition(position, str, _close ? 2 : 1);\n    var end = copyPosition(position);\n    state.tokens.push({\n      type: 'tag-end',\n      close: _close,\n      position: {\n        end: end\n      }\n    });\n  }\n  return tagName;\n} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\n\n\nvar whitespace = /\\s/;\n\nfunction isWhitespaceChar(_char3) {\n  return whitespace.test(_char3);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      position = state.position;\n  var len = str.length;\n  var start = position.index;\n\n  while (start < len) {\n    var _char4 = str.charAt(start);\n\n    var isTagChar = !(isWhitespaceChar(_char4) || _char4 === '/' || _char4 === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n\n  while (end < len) {\n    var _char5 = str.charAt(end);\n\n    var _isTagChar = !(isWhitespaceChar(_char5) || _char5 === '/' || _char5 === '>');\n\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  jumpPosition(position, str, end);\n  var tagName = str.slice(start, end);\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n  var cursor = position.index;\n  var quote = null; // null, single-, or double-quote\n\n  var wordBegin = cursor; // index of word start\n\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n\n  var len = str.length;\n\n  while (cursor < len) {\n    var _char6 = str.charAt(cursor);\n\n    if (quote) {\n      var isQuoteEnd = _char6 === quote;\n\n      if (isQuoteEnd) {\n        quote = null;\n      }\n\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = _char6 === '/' || _char6 === '>';\n\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(_char6);\n\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = _char6 === '\\'' || _char6 === '\"';\n\n    if (isQuoteStart) {\n      quote = _char6;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n\n  jumpPosition(position, str, cursor);\n  var wLen = words.length;\n  var type = 'attribute';\n\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({\n            type: type,\n            content: newWord\n          });\n          i += 1;\n          continue;\n        }\n\n        var thirdWord = words[i + 2];\n        i += 1;\n\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n\n          tokens.push({\n            type: type,\n            content: _newWord\n          });\n          i += 1;\n          continue;\n        }\n      }\n    }\n\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n\n        tokens.push({\n          type: type,\n          content: _newWord3\n        });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n\n      tokens.push({\n        type: type,\n        content: _newWord2\n      });\n      continue;\n    }\n\n    tokens.push({\n      type: type,\n      content: word\n    });\n  }\n}\n\nvar push = [].push;\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n  var safeTagName = tagName.toLowerCase();\n  var len = str.length;\n  var index = position.index;\n\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagStartPosition = copyPosition(position);\n    jumpPosition(tagStartPosition, str, nextTag);\n    var tagState = {\n      str: str,\n      position: tagStartPosition,\n      tokens: []\n    };\n    var name = lexTag(tagState);\n\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index;\n      continue;\n    }\n\n    if (nextTag !== position.index) {\n      var textStart = copyPosition(position);\n      jumpPosition(position, str, nextTag);\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      });\n    }\n\n    push.apply(tokens, tagState.tokens);\n    jumpPosition(position, str, tagState.position.index);\n    break;\n  }\n}\n\n},{\"./compat\":1}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.parse = parse;\nexports.rewindStack = rewindStack;\n\nvar _compat = require(\"./compat\");\n\nfunction parser(tokens, options) {\n  var root = {\n    tagName: null,\n    children: []\n  };\n  var state = {\n    tokens: tokens,\n    options: options,\n    cursor: 0,\n    stack: [root]\n  };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n\n      if (parentTagName === tagName) {\n        break;\n      }\n\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n\n      currentIndex--;\n    }\n  }\n\n  return false;\n}\n\nfunction rewindStack(stack, newLength, childrenEndPosition, endPosition) {\n  stack[newLength].position.end = endPosition;\n\n  for (var i = newLength + 1, len = stack.length; i < len; i++) {\n    stack[i].position.end = childrenEndPosition;\n  }\n\n  stack.splice(newLength);\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n\n    if (token.close) {\n      var index = stack.length;\n      var shouldRewind = false;\n\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true;\n          break;\n        }\n      }\n\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n\n      if (shouldRewind) {\n        rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          rewindStack(stack, currentIndex, token.position.start, token.position.start);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    var position = {\n      start: token.position.start,\n      end: attrToken.position.end\n    };\n    var elementNode = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children,\n      position: position\n    };\n    nodes.push(elementNode);\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n\n    if (hasChildren) {\n      var size = stack.push({\n        tagName: tagName,\n        children: children,\n        position: position\n      });\n      var innerState = {\n        tokens: tokens,\n        options: options,\n        cursor: cursor,\n        stack: stack\n      };\n      parse(innerState);\n      cursor = innerState.cursor;\n      var rewoundInElement = stack.length === size;\n\n      if (rewoundInElement) {\n        elementNode.position.end = tokens[cursor - 1].position.end;\n      }\n    }\n  }\n\n  state.cursor = cursor;\n}\n\n},{\"./compat\":1}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nexports.formatAttributes = formatAttributes;\nexports.toHTML = toHTML;\n\nvar _compat = require(\"./compat\");\n\nfunction formatAttributes(attributes) {\n  return attributes.reduce(function (attrs, attribute) {\n    var key = attribute.key,\n        value = attribute.value;\n\n    if (value === null) {\n      return \"\".concat(attrs, \" \").concat(key);\n    }\n\n    var quoteEscape = value.indexOf('\\'') !== -1;\n    var quote = quoteEscape ? '\"' : '\\'';\n    return \"\".concat(attrs, \" \").concat(key, \"=\").concat(quote).concat(value).concat(quote);\n  }, '');\n}\n\nfunction toHTML(tree, options) {\n  return tree.map(function (node) {\n    if (node.type === 'text') {\n      return node.content;\n    }\n\n    if (node.type === 'comment') {\n      return \"<!--\".concat(node.content, \"-->\");\n    }\n\n    var tagName = node.tagName,\n        attributes = node.attributes,\n        children = node.children;\n    var isSelfClosing = (0, _compat.arrayIncludes)(options.voidTags, tagName.toLowerCase());\n    return isSelfClosing ? \"<\".concat(tagName).concat(formatAttributes(attributes), \">\") : \"<\".concat(tagName).concat(formatAttributes(attributes), \">\").concat(toHTML(children, options), \"</\").concat(tagName, \">\");\n  }).join('');\n}\n\nvar _default = {\n  toHTML: toHTML\n};\nexports[\"default\"] = _default;\n\n},{\"./compat\":1}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.voidTags = exports.closingTags = exports.closingTagAncestorBreakers = exports.childlessTags = void 0;\n\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = ['style', 'script', 'template'];\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\n\nexports.childlessTags = childlessTags;\nvar closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\n\nexports.closingTags = closingTags;\nvar closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n};\n/*\n  Tags which do not need the closing tag\n  For example: <img> does not need </img>\n*/\n\nexports.closingTagAncestorBreakers = closingTagAncestorBreakers;\nvar voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nexports.voidTags = voidTags;\n\n},{}]},{},[3])(3)\n});"],"file":"himalaya.js"}